/*! For license information please see tsparticles.path.perlin.noise.min.js.LICENSE.txt */
!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t(require("@tsparticles/engine"),require("@tsparticles/perlin-noise"));else if("function"==typeof define&&define.amd)define(["@tsparticles/engine","@tsparticles/perlin-noise"],t);else{var i="object"==typeof exports?t(require("@tsparticles/engine"),require("@tsparticles/perlin-noise")):t(e.window,e.window);for(var o in i)("object"==typeof exports?exports:e)[o]=i[o]}}(this,((e,t)=>(()=>{var i={303:t=>{t.exports=e},846:e=>{e.exports=t}},o={};function s(e){var t=o[e];if(void 0!==t)return t.exports;var n=o[e]={exports:{}};return i[e](n,n.exports,s),n.exports}s.d=(e,t)=>{for(var i in t)s.o(t,i)&&!s.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},s.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),s.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};s.r(n),s.d(n,{loadPerlinNoisePath:()=>d,perlinNoisePathName:()=>f});var r=s(303),a=s(846);const l=2*Math.PI,h={draw:!1,size:20,increment:.004,columns:0,rows:0,width:0,height:0,factor:{angle:.02,length:.01},offset:{x:4e4,y:4e4}};class c{constructor(){this._calculateField=()=>{const{field:e,noiseGen:t,options:i}=this,o=i.factor.length,s=i.factor.angle;for(let n=0;n<i.columns;n++){const r=e[n];for(let e=0;e<i.rows;e++){const a=r[e];a.length=t.noise3d(n*o+i.offset.x,e*o+i.offset.y,this.noiseZ),a.angle=t.noise3d(n*s,e*s,this.noiseZ)*l}}},this._drawField=e=>{const{field:t,options:i}=this;for(let o=0;o<i.columns;o++){const s=t[o];for(let t=0;t<i.rows;t++){const i=s[t],{angle:n,length:r}=i;e.setTransform(1,0,0,1,o*this.options.size,t*this.options.size),e.rotate(n),e.strokeStyle="white",e.beginPath(),e.moveTo(0,0),e.lineTo(0,this.options.size*r),e.stroke(),e.setTransform(1,0,0,1,0,0)}}},this._initField=()=>{const{columns:e,rows:t}=this.options;this.field=new Array(e);for(let i=0;i<e;i++){this.field[i]=new Array(t);for(let e=0;e<t;e++)this.field[i][e]=r.Vector.origin}},this.noiseGen=new a.PerlinNoise,this.field=[],this.noiseZ=0,this.options=(0,r.deepExtend)({},h)}generate(e){const t=e.getPosition(),{size:i}=this.options,o=Math.max(Math.floor(t.x/i),0),s=Math.max(Math.floor(t.y/i),0),{field:n}=this;return n?.[o]?.[s]?n[o][s].copy():r.Vector.origin}init(e){this.container=e,this._setup()}reset(){}update(){this.container&&(this._calculateField(),this.noiseZ+=this.options.increment,this.options.draw&&this.container.canvas.draw((e=>this._drawField(e))))}_resetField(){const e=this.container;if(!e)return;const t=e.actualOptions.particles.move.path.options,{options:i}=this;i.size=t.size>0?t.size:h.size,i.increment=t.increment>0?t.increment:h.increment,i.draw=!!t.draw;const o=t.offset;i.offset.x=o?.x??h.offset.x,i.offset.y=o?.y??h.offset.y;const s=t.factor;i.factor.angle=s?.angle??h.factor.angle,i.factor.length=s?.length??h.factor.length,i.width=e.canvas.size.width,i.height=e.canvas.size.height,this.options.seed=t.seed,this.noiseGen.seed(this.options.seed??(0,r.getRandom)()),i.columns=Math.floor(this.options.width/this.options.size)+1,i.rows=Math.floor(this.options.height/this.options.size)+1,this._initField()}_setup(){this.noiseZ=0,this._resetField(),window.addEventListener("resize",(()=>this._resetField()))}}const f="perlinNoise";async function d(e,t=!0){await e.addPathGenerator(f,new c,t)}return n})()));