/*! For license information please see tsparticles.shape.path.min.js.LICENSE.txt */
!function(e,a){if("object"==typeof exports&&"object"==typeof module)module.exports=a(require("@tsparticles/engine"));else if("function"==typeof define&&define.amd)define(["@tsparticles/engine"],a);else{var t="object"==typeof exports?a(require("@tsparticles/engine")):a(e.window);for(var s in t)("object"==typeof exports?exports:e)[s]=t[s]}}(this,(e=>(()=>{var a={303:a=>{a.exports=e}},t={};function s(e){var r=t[e];if(void 0!==r)return r.exports;var l=t[e]={exports:{}};return a[e](l,l.exports,s),l.exports}s.d=(e,a)=>{for(var t in a)s.o(a,t)&&!s.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:a[t]})},s.o=(e,a)=>Object.prototype.hasOwnProperty.call(e,a),s.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var r={};s.r(r),s.d(r,{loadPathShape:()=>u});var l,o=s(303);!function(e){e.line="line",e.bezier="bezier",e.quadratic="quadratic",e.arc="arc",e.ellipse="ellipse"}(l||(l={}));class i{constructor(){this.validTypes=["path"]}draw(e){const{context:a,particle:t,radius:s}=e;t.pathData&&function(e,a,t){const s=t.segments[0].values[0];e.moveTo(s.x*a,s.y*a);for(const s of t.segments){const t=s.values[0],r=1,o=2,i=3;switch(s.type){case l.line:e.lineTo(t.x*a,t.y*a);break;case l.bezier:e.bezierCurveTo(s.values[r].x*a,s.values[r].y*a,s.values[o].x*a,s.values[o].y*a,s.values[i].x*a,s.values[i].y*a);break;case l.quadratic:e.quadraticCurveTo(s.values[r].x*a,s.values[r].y*a,s.values[o].x*a,s.values[o].y*a);break;case l.arc:e.arc(t.x*a,t.y*a,s.values[r].x*a,s.values[o].x,s.values[o].y);break;case l.ellipse:e.ellipse(t.x*a,t.y*a,s.values[r].x*a,s.values[r].y*a,s.values[o].x,s.values[i].x,s.values[i].y)}}if(!t.half)return;for(let s=t.segments.length-1;s>=0;s--){const r=t.segments[s],o=r.values[0],i=1,u=2;switch(r.type){case l.line:e.lineTo(o.x*-a,o.y*a);break;case l.bezier:e.bezierCurveTo(-r.values[u].x*a,r.values[u].y*a,-r.values[i].x*a,r.values[i].y*a,o.x*a,o.y*a);break;case l.quadratic:e.quadraticCurveTo(-r.values[i].x*a,r.values[i].y*a,-r.values[u].x*a,r.values[u].y*a);case l.arc:case l.ellipse:}}}(a,s,t.pathData)}particleInit(e,a){const t=a.shapeData;t&&(a.pathData=(0,o.deepExtend)({},t))}}async function u(e,a=!0){await e.addShape(new i,a)}return r})()));