/*! For license information please see tsparticles.path.curves.min.js.LICENSE.txt */
!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t(require("@tsparticles/engine"));else if("function"==typeof define&&define.amd)define(["@tsparticles/engine"],t);else{var n="object"==typeof exports?t(require("@tsparticles/engine")):t(e.window);for(var o in n)("object"==typeof exports?exports:e)[o]=n[o]}}(this,(e=>(()=>{var t={303:t=>{t.exports=e}},n={};function o(e){var r=n[e];if(void 0!==r)return r.exports;var i=n[e]={exports:{}};return t[e](i,i.exports,o),i.exports}o.d=(e,t)=>{for(var n in t)o.o(t,n)&&!o.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},o.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),o.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var r={};o.r(r),o.d(r,{curvesPathName:()=>l,loadCurvesPath:()=>s});var i=o(303);const a=2*Math.PI;class c{constructor(){this.options={rndFunc:null,period:100,nbHarmonics:2,attenHarmonics:.8,lowValue:-.03,highValue:.03}}generate(e){if(!e.pathGen){const t=this.options;e.pathGen=function(e,t,n,o,r=0,a=1){const c=[],l=[],s=[],u=[],p=[],d=e??i.getRandom;let h=0;n<1&&(n=1);for(let e=1;e<=n;++e)c[e]=d(),l[e]=d(),s[e]=1===e?1:s[e-1]*o,h+=s[e],u[e]=e/t,p[e]=d();return s.forEach(((e,t)=>s[t]=e/h*(a-r))),()=>{let e,t,o=0;for(let r=n;r>=1;--r)e=p[r]+=u[r],p[r]>=1&&(e=p[r]-=1,c[r]=l[r],l[r]=d()),t=e**2*(3-2*e),o+=(c[r]*(1-t)+l[r]*t)*s[r];return o+r}}(t.rndFunc,t.period,t.nbHarmonics,t.attenHarmonics,t.lowValue,t.highValue)}return e.curveVelocity?(e.curveVelocity.length+=.01,e.curveVelocity.angle=(e.curveVelocity.angle+e.pathGen())%a):(e.curveVelocity=i.Vector.origin,e.curveVelocity.length=.6*(0,i.getRandom)()+.8,e.curveVelocity.angle=(0,i.getRandom)()*a),e.velocity.x=0,e.velocity.y=0,e.curveVelocity}init(e){const t=e.actualOptions.particles.move.path.options,{options:n}=this;(0,i.isFunction)(t.rndFunc)?n.rndFunc=t.rndFunc:(0,i.isString)(t.rndFunc)&&(n.rndFunc=window[t.rndFunc]??this.options.rndFunc),n.period=t.period??n.period,n.nbHarmonics=t.nbHarmonics??n.nbHarmonics,n.attenHarmonics=t.attenHarmonics??n.attenHarmonics,n.lowValue=t.lowValue??n.lowValue,n.highValue=t.highValue??n.highValue}reset(e){delete e.pathGen,delete e.curveVelocity}update(){}}const l="curvesPathGenerator";async function s(e,t=!0){await e.addPathGenerator(l,new c,t)}return r})()));