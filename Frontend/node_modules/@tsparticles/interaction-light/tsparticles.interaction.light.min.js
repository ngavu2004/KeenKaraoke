/*! For license information please see tsparticles.interaction.light.min.js.LICENSE.txt */
!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e(require("@tsparticles/engine"));else if("function"==typeof define&&define.amd)define(["@tsparticles/engine"],e);else{var o="object"==typeof exports?e(require("@tsparticles/engine")):e(t.window);for(var i in o)("object"==typeof exports?exports:t)[i]=o[i]}}(this,(t=>(()=>{var e={303:e=>{e.exports=t}},o={};function i(t){var r=o[t];if(void 0!==r)return r.exports;var s=o[t]={exports:{}};return e[t](s,s.exports,i),s.exports}i.d=(t,e)=>{for(var o in e)i.o(e,o)&&!i.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var r={};i.r(r),i.d(r,{Light:()=>f,LightArea:()=>p,LightGradient:()=>u,LightShadow:()=>g,loadLightInteraction:()=>m});var s=i(303);const n=1,a=0,l=.5*Math.PI,c=2*Math.PI,d=.25*Math.PI,h="light";class u{constructor(){this.start=new s.OptionsColor,this.stop=new s.OptionsColor,this.start.value="#ffffff",this.stop.value="#000000"}load(t){t&&(this.start=s.OptionsColor.create(this.start,t.start),this.stop=s.OptionsColor.create(this.stop,t.stop))}}class p{constructor(){this.gradient=new u,this.radius=1e3}load(t){t&&(this.gradient.load(t.gradient),void 0!==t.radius&&(this.radius=t.radius))}}class g{constructor(){this.color=new s.OptionsColor,this.color.value="#000000",this.length=2e3}load(t){t&&(this.color=s.OptionsColor.create(this.color,t.color),void 0!==t.length&&(this.length=t.length))}}class f{constructor(){this.area=new p,this.shadow=new g}load(t){t&&(this.area.load(t.area),this.shadow.load(t.shadow))}}class v extends s.ExternalInteractorBase{constructor(t){super(t)}clear(){}init(){}interact(){const t=this.container,e=t.actualOptions,o=t.interactivity;if(!e.interactivity.events.onHover.enable||"pointermove"!==o.status)return;const i=o.mouse.position;i&&t.canvas.draw((e=>{!function(t,e,o){const i=t.actualOptions.interactivity.modes.light?.area;if(!i)return;e.beginPath(),e.arc(o.x,o.y,i.radius,0,c);const r=e.createRadialGradient(o.x,o.y,0,o.x,o.y,i.radius),l=t.canvas.mouseLight;l?.start&&l.stop&&(r.addColorStop(a,(0,s.getStyleFromRgb)(l.start)),r.addColorStop(n,(0,s.getStyleFromRgb)(l.stop)),e.fillStyle=r,e.fill())}(t,e,i)}))}isEnabled(t){const e=this.container,o=e.interactivity.mouse,i=t?.interactivity??e.actualOptions.interactivity,r=i.events;if(!r.onHover.enable||!o.position)return!1;const n=(0,s.isInArray)(h,r.onHover.mode);if(n&&i.modes.light){const t=i.modes.light.area.gradient;e.canvas.mouseLight={start:(0,s.rangeColorToRgb)(t.start),stop:(0,s.rangeColorToRgb)(t.stop)}}return n}loadModeOptions(t,...e){t.light||(t.light=new f);for(const o of e)t.light.load(o?.light)}reset(){}}class y extends s.ParticlesInteractorBase{constructor(t){super(t)}clear(){}init(){}interact(t){const e=this.container,o=e.actualOptions,i=e.interactivity;if(!o.interactivity.events.onHover.enable||"pointermove"!==i.status)return;const r=i.mouse.position;r&&e.canvas.draw((o=>{!function(t,e,o,i){const r=o.getPosition(),n=t.actualOptions.interactivity.modes.light?.shadow;if(!n)return;const a=o.lightShadow;if(!a)return;const h=o.getRadius(),u=o.sides,p=c/u,g=-o.rotation+d,f=[];for(let t=0;t<u;t++)f.push({x:r.x+h*Math.sin(g+p*t)*1,y:r.y+h*Math.cos(g+p*t)*1});const v=[],y=n.length;for(const t of f){const e=Math.atan2(i.y-t.y,i.x-t.x),o={x:t.x+y*Math.sin(-e-l),y:t.y+y*Math.cos(-e-l)};v.push({end:o,start:t})}const m=(0,s.getStyleFromRgb)(a);for(let t=v.length-1,o=0;t>=0;o=t--)e.beginPath(),e.moveTo(v[t].start.x,v[t].start.y),e.lineTo(v[o].start.x,v[o].start.y),e.lineTo(v[o].end.x,v[o].end.y),e.lineTo(v[t].end.x,v[t].end.y),e.fillStyle=m,e.fill()}(e,o,t,r)}))}isEnabled(t){const e=this.container,o=t.interactivity??e.actualOptions.interactivity,i=e.interactivity.mouse,r=o.events;if(!r.onHover.enable||!i.position)return!1;const n=(0,s.isInArray)(h,r.onHover.mode);if(n&&o.modes.light){const e=o.modes.light.shadow;t.lightShadow=(0,s.rangeColorToRgb)(e.color)}return n}reset(){}}async function m(t,e=!0){await t.addInteractor("externalLight",(t=>Promise.resolve(new v(t))),e),await t.addInteractor("particlesLight",(t=>Promise.resolve(new y(t))),e)}return r})()));