/*! For license information please see tsparticles.updater.gradient.min.js.LICENSE.txt */
!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t(require("@tsparticles/engine"));else if("function"==typeof define&&define.amd)define(["@tsparticles/engine"],t);else{var a="object"==typeof exports?t(require("@tsparticles/engine")):t(e.window);for(var i in a)("object"==typeof exports?exports:e)[i]=a[i]}}(this,(e=>(()=>{var t={303:t=>{t.exports=e}},a={};function i(e){var n=a[e];if(void 0!==n)return n.exports;var o=a[e]={exports:{}};return t[e](o,o.exports,i),o.exports}i.d=(e,t)=>{for(var a in t)i.o(t,a)&&!i.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};i.r(n),i.d(n,{loadGradientUpdater:()=>g});var o=i(303);class s{constructor(){this.count=0,this.enable=!1,this.speed=0,this.decay=0,this.delay=0,this.sync=!1,this.startValue=o.StartValueType.random}load(e){e&&(void 0!==e.count&&(this.count=(0,o.setRangeValue)(e.count)),void 0!==e.enable&&(this.enable=e.enable),void 0!==e.speed&&(this.speed=(0,o.setRangeValue)(e.speed)),void 0!==e.sync&&(this.sync=e.sync),void 0!==e.startValue&&(this.startValue=e.startValue),void 0!==e.decay&&(this.decay=(0,o.setRangeValue)(e.decay)),void 0!==e.delay&&(this.delay=(0,o.setRangeValue)(e.delay)))}}class l{constructor(){this.value=0,this.animation=new s}load(e){e&&(this.animation.load(e.animation),void 0!==e.value&&(this.value=(0,o.setRangeValue)(e.value)))}}class r{constructor(){this.stop=0,this.value=new o.AnimatableColor}load(e){e&&(void 0!==e.stop&&(this.stop=e.stop),this.value=o.AnimatableColor.create(this.value,e.value),void 0!==e.opacity&&(this.opacity=new l,(0,o.isNumber)(e.opacity)?this.opacity.value=e.opacity:this.opacity.load(e.opacity)))}}class c{constructor(){this.count=0,this.enable=!1,this.speed=0,this.decay=0,this.delay=0,this.sync=!1}load(e){e&&(void 0!==e.count&&(this.count=(0,o.setRangeValue)(e.count)),void 0!==e.enable&&(this.enable=e.enable),void 0!==e.speed&&(this.speed=(0,o.setRangeValue)(e.speed)),void 0!==e.decay&&(this.decay=(0,o.setRangeValue)(e.decay)),void 0!==e.delay&&(this.delay=(0,o.setRangeValue)(e.delay)),void 0!==e.sync&&(this.sync=e.sync))}}class d{constructor(){this.value=0,this.animation=new c,this.direction=o.RotateDirection.clockwise}load(e){e&&(this.animation.load(e.animation),void 0!==e.value&&(this.value=(0,o.setRangeValue)(e.value)),void 0!==e.direction&&(this.direction=e.direction))}}class u{constructor(){this.angle=new d,this.colors=[],this.type=o.GradientType.random}load(e){e&&(this.angle.load(e.angle),void 0!==e.colors&&(this.colors=e.colors.map((e=>{const t=new r;return t.load(e),t}))),void 0!==e.type&&(this.type=e.type))}}const p=2*Math.PI;class y{getColorStyles(e,t,a,i){const n=e.gradient;if(!n)return{};const s=n.angle.value,l=0,r=0,c=n.type===o.GradientType.radial?t.createRadialGradient(l,r,0,l,r,a):t.createLinearGradient(Math.cos(s)*-a,Math.sin(s)*-a,Math.cos(s)*a,Math.sin(s)*a);for(const{stop:e,value:t,opacity:a}of n.colors)c.addColorStop(e,(0,o.getStyleFromHsl)({h:t.h.value,s:t.s.value,l:t.l.value},a?.value??i));return{fill:c}}init(e){const t=(0,o.itemFromSingleOrMultiple)(e.options.gradient);if(!t)return;const{angle:a}=t;e.gradient={angle:{value:(0,o.getRangeValue)(a.value),enable:a.animation.enable,velocity:(0,o.getRangeValue)(a.animation.speed)/360*e.container.retina.reduceFactor,decay:1-(0,o.getRangeValue)(a.animation.decay),delayTime:(0,o.getRangeValue)(a.animation.delay)*o.millisecondsToSeconds,max:p,min:0,time:0},type:t.type,colors:[]};let i=t.angle.direction;switch(i===o.RotateDirection.random&&(i=(0,o.getRandom)()>o.halfRandom?o.RotateDirection.counterClockwise:o.RotateDirection.clockwise),i){case o.RotateDirection.counterClockwise:case"counterClockwise":e.gradient.angle.status=o.AnimationStatus.decreasing;break;case o.RotateDirection.clockwise:e.gradient.angle.status=o.AnimationStatus.increasing}const n=e.options.reduceDuplicates;for(const a of t.colors){const t=(0,o.rangeColorToHsl)(a.value,e.id,n);if(!t)continue;const i=(0,o.getHslAnimationFromHsl)(t,a.value.animation,e.container.retina.reduceFactor),s={stop:a.stop,value:i,opacity:a.opacity?{enable:a.opacity.animation.enable,max:(0,o.getRangeMax)(a.opacity.value),min:(0,o.getRangeMin)(a.opacity.value),status:o.AnimationStatus.increasing,value:(0,o.getRangeValue)(a.opacity.value),velocity:(0,o.getRangeValue)(a.opacity.animation.speed)/o.percentDenominator*e.container.retina.reduceFactor,decay:1-(0,o.getRangeValue)(a.opacity.animation.decay),delayTime:(0,o.getRangeValue)(a.opacity.animation.delay)*o.millisecondsToSeconds,time:0}:void 0},{opacity:l}=s;if(a.opacity&&l){const e=a.opacity.value;l.min=(0,o.getRangeMin)(e),l.max=(0,o.getRangeMax)(e);switch(a.opacity.animation.startValue){case o.StartValueType.min:l.value=l.min,l.status=o.AnimationStatus.increasing;break;case o.StartValueType.max:l.value=l.max,l.status=o.AnimationStatus.decreasing;break;case o.StartValueType.random:default:l.value=(0,o.randomInRange)(l),l.status=(0,o.getRandom)()>=o.halfRandom?o.AnimationStatus.increasing:o.AnimationStatus.decreasing}}e.gradient.colors.push(s)}}isEnabled(e){return!e.destroyed&&!e.spawning&&(!!e.gradient?.angle.enable||(e.gradient?.colors.some((e=>e.value.h.enable||e.value.s.enable||e.value.l.enable))??!1))}loadOptions(e,...t){for(const a of t){if(!a?.gradient)continue;const t=a.gradient;t&&(e.gradient=(0,o.executeOnSingleOrMultiple)(t,(e=>{const t=new u;return t.load(e),t})))}}update(e,t){!function(e,t){const{gradient:a}=e;if(a){(0,o.updateAnimation)(e,a.angle,!1,o.DestroyType.none,t);for(const i of a.colors)(0,o.updateColor)(i.value,t),i.opacity&&(0,o.updateAnimation)(e,i.opacity,!0,o.DestroyType.none,t)}}(e,t)}}async function g(e,t=!0){await e.addParticleUpdater("gradient",(()=>Promise.resolve(new y)),t)}return n})()));